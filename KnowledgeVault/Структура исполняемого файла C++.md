#Memory
# Структура исполняемого файла [[C++]]
Исполняемый файл всегда содержит частичный образ программы, который будет загружен в память при его запуске. Частичный - потому что скорее всего программа будет динамически выделять память в куче ([[Memory Heap (Куча)]]).
Исполняемый образ делится на непрерывные блоки, называемые сегментами или секциями. Каждая операционная система располагает их по-своему, и расстановка может также немного различаться от одного исполняемого файла к другому в той же операционной системе. Образ обычно состоит как минимум из следующих четырех сегментов.
1. **Текстовый сегмент.** Иногда называемый сегментом кода, этот блок содержит исполняемый машинный код для всех функций, определенных программой.
2. **Сегмент данных.** Содержит все инициализированные глобальные и статические переменные. Память, необходимая для каждой глобальной переменной, распределяется точно так же, как она будет отображаться при запуске программы, и все правильные нужные значения заполняются. Поэтому, когда исполняемый файл загружается в память, инициализированные глобальные и статические переменные готовы к работе.
3. **Сегмент BSS. BSS** — это устаревшее сокращение, которое означает «блок, начинающийся с символа» (block started by symbol). Этот сегмент содержит все определенные, но не инициализированные программой глобальные и статические переменные. Языки C и C++ явно определяют начальное значение любой неинициализированной глобальной или статической переменной равным нулю. Но вместо того, чтобы хранить потенциально очень большой блок нулей в разделе BSS, компоновщик просто хранит счетчик того, сколько нулевых байтов требуется для учета всех неинициализированных глобальных и статических переменных в сегменте. Когда исполняемый файл загружается в память, операционная система резервирует запрошенное количество байтов для раздела BSS и заполняет его нулями до вызова точки входа в программу, например main() или WinMain().
4. **Сегмент данных только для чтения.** Иногда называемый сегментом **rodata**, он содержит любые глобальные данные только для чтения (постоянные), определенные программой. Так, в этом сегменте находятся все константы с плавающей точкой (например, `const float kPi = 3.141592f;`) и все экземпляры глобальных объектов, которые были объявлены с помощью ключевого слова const (например, `const Foo gReadOnlyFoo;`). Обратите внимание на то, что целочисленные константы (например, `const int kMaxMonsters = 255;`) часто используются компилятором в качестве именованных констант, то есть вставляются непосредственно в машинный код, где бы они ни использовались. Такие константы занимают место в текстовом сегменте, но их нет в сегменте данных только для чтения.****