# Cooperative multitasking

As operating systems and computer hardware became more advanced, it became possible to run more than one program on a serial computer at a time. On shared mainframe computer systems, a technique known as multiprogramming would allow one program to run while another was waiting for a time consuming request to be satisifed by a peripheral device. Classic Mac OS and versions of Windows prior to Windows NT and Windows 95 used a technique known as <mark style="background: #D2B3FFA6;">cooperative multitasking</mark>, in which only one program would be running on the machine at a time, but each program would regularly yield the CPU so that another program could get a chance to run. In this way, each program ended up with a periodic “slice” of CPU time. Technically, this technique is known as <mark style="background: #D2B3FFA6;">time division multiplexing</mark> (TDM) or <mark style="background: #D2B3FFA6;">temporal multithreading</mark> (TMT). Informally it’s called <mark style="background: #D2B3FFA6;">time-slicing.</mark> 

Cooperative multitasking suffered from one big problem: Time-slicing required the cooperation of each and every program in the system. One “rogue” program could consume all of the CPU’s time if it failed to yield to other programs periodically. The PDP-6 Monitor and Multics operating systems solved this problem by introducing a technique known as [[Preemptive Multitasking]]. This technology was later adopted by the UNIX operating system and all of its variants, along with later versions of Mac OS and Windows.